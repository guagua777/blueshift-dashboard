{
  "courses": {
    "blockchain-fundamentals": {
      "title": "Blockchain Fundamentals",
      "description": "Understand digital trust and blockchain architecture. Learn how cryptographic primitives, consensus mechanisms, and Bitcoin's UTXO model solve the double-spending problem.",
      "lessons": {
        "digital-trust-problem": {
          "title": "The Double-Spending Problem",
          "description": "Learn why digital money failed before blockchain. Understand the double-spending problem, why banks charge fees, and how central authorities control financial systems."
        },
        "how-blockchains-work": {
          "title": "How Blockchains Work",
          "description": "Discover how hash functions, digital signatures, and Merkle trees create trust without central authority. Learn the cryptographic primitives powering blockchain security."
        },
        "achieving-consensus": {
          "title": "Proof of Work and Proof of Stake",
          "description": "Master Proof of Work and Proof of Stake consensus mechanisms. Understand Byzantine Fault Tolerance and how blockchains achieve agreement without central authority."
        },
        "bitcoin-first-blockchain": {
          "title": "How Bitcoin Works",
          "description": "Understand how Bitcoin works with the UTXO model, mining rewards, and block difficulty. Learn what Bitcoin does well and its fundamental limitations."
        },
        "conclusion": {
          "title": "Key Takeaways",
          "description": "Review key blockchain concepts with comprehensive FAQ. Understand double-spending, consensus mechanisms, Proof of Work vs Stake, UTXO model, and Bitcoin's limitations."
        }
      }
    },
    "evolution-programmable-blockchains": {
      "title": "Evolution of Programmable Blockchains",
      "description": "From Bitcoin to smart contracts. Learn how Ethereum introduced programmable money, why sequential execution creates bottlenecks, and how different solutions tackle scalability.",
      "lessons": {
        "ethereum-programmable-money": {
          "title": "Ethereum and Programmable Money",
          "description": "Understand Ethereum smart contracts and composability. Learn how Ethereum transformed blockchain from payments to programmable money enabling DeFi, NFTs, and DAOs."
        },
        "how-ethereum-works": {
          "title": "State, the EVM, and Gas",
          "description": "Learn what blockchain state is, how the EVM executes smart contracts, and why gas fees exist. Understand the account model and sequential execution that shapes Ethereum's design."
        },
        "scalability-challenge": {
          "title": "The Scalability Problem",
          "description": "Learn why Ethereum is slow processing only 15 TPS. Understand sequential execution bottlenecks, the blockchain trilemma, and why fast blocks don't solve scalability."
        },
        "solutions-landscape": {
          "title": "Rollups, Sidechains, and Alternative L1s",
          "description": "Compare Layer 2 solutions, rollups (optimistic and ZK), sidechains, sharding, and alternative L1 blockchains. Understand tradeoffs in blockchain scaling approaches."
        },
        "conclusion": {
          "title": "Key Takeaways",
          "description": "Review programmable blockchain concepts with comprehensive FAQ. Understand Ethereum smart contracts, scalability trilemma, Layer 2 solutions, rollups, and alternative L1s."
        }
      }
    },
    "understanding-solana": {
      "title": "Understanding Solana",
      "description": "Learn Solana's architecture from first principles. Understand Proof of History, the account model, stateless programs, and why everything being an account enables parallel execution.",
      "lessons": {
        "why-solana-built": {
          "title": "Why Solana Was Built",
          "description": "Master Solana's Proof of History and parallel execution. Learn how Solana achieves 5,000+ TPS with sub-second finality through ordering before consensus."
        },
        "solana-architecture": {
          "title": "Solana Architecture",
          "description": "Understand Solana's account model and stateless programs. Learn why declaring accounts upfront enables parallel execution achieving high throughput."
        },
        "accounts-ownership": {
          "title": "Accounts and Ownership",
          "description": "Learn Solana account structure, ownership rules, and rent mechanism. Understand how accounts store data, programs, and tokens on Solana blockchain."
        },
        "programs-transactions": {
          "title": "Programs and Transactions",
          "description": "Master Solana programs, instructions, and transactions. Learn about PDAs, CPI, and how Solana executes smart contracts with parallel processing."
        },
        "using-solana": {
          "title": "Using Solana",
          "description": "Set up a Solana wallet, send transactions, and explore the ecosystem. Learn to use Phantom wallet, get SOL, and navigate DeFi and NFT applications."
        },
        "conclusion": {
          "title": "Key Takeaways",
          "description": "Review Solana architecture with comprehensive FAQ. Understand Proof of History, account model, stateless programs, PDAs, transactions, and getting started."
        }
      }
    },
    "anchor-for-dummies": {
      "title": "Anchor for Dummies",
      "description": "Go from zero to deploying your first Solana program. Learn PDAs, CPIs, testing, and client integration. 8 lessons with real code you'll actually use.",
      "lessons": {
        "anchor-101": {
          "title": "Anchor 101",
          "description": "Build Solana smart contracts with Anchor framework. Reduce boilerplate, implement security checks, and use procedural macros efficiently."
        },
        "anchor-accounts": {
          "title": "Anchor Accounts",
          "description": "Define program accounts, implement discriminators, and manage account state. Master Anchor account types and validation patterns."
        },
        "anchor-instructions": {
          "title": "Anchor Instructions",
          "description": "Create instruction handlers with Context structs. Access accounts, program ID, remaining accounts, and PDA bumps in Anchor."
        },
        "testing-your-program": {
          "title": "Testing your Program",
          "description": "Test Anchor programs with TypeScript and Mollusk. Run integration tests, mock blockchain state, and validate program behavior."
        },
        "program-deployment": {
          "title": "Program Deployment",
          "description": "Deploy Anchor programs to devnet and mainnet. Build bytecode, configure program IDs, and handle deployment failures."
        },
        "client-side-development": {
          "title": "Client Side Development",
          "description": "Build TypeScript clients with Anchor IDL and SDK. Connect wallet adapters, create Provider objects, and call program instructions."
        },
        "advanced-anchor": {
          "title": "Advanced Anchor",
          "description": "Use Cargo feature flags for environment-specific configurations. Implement conditional compilation and optimize production builds."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review Anchor framework fundamentals, program structure, and discriminators. Start building secure Solana programs with hands-on practice."
        }
      }
    },
    "pinocchio-for-dummies": {
      "title": "Pinocchio for Dummies",
      "description": "Build Solana programs that are actually fast. Master zero-copy deserialization, batch multiple instructions, and squeeze every compute unit. Performance matters.",
      "lessons": {
        "pinocchio-101": {
          "title": "Pinocchio 101",
          "description": "Build lightweight Solana programs with Pinocchio zero-copy framework. Reduce compute units, shrink binary size, and eliminate dependencies."
        },
        "pinocchio-accounts": {
          "title": "Pinocchio Accounts",
          "description": "Implement manual account validation with TryFrom trait. Perform signer checks, owner verification, and discriminator validation."
        },
        "pinocchio-instructions": {
          "title": "Pinocchio Instructions",
          "description": "Structure instruction logic with TryFrom validation pattern. Separate validation from business logic for maintainable code."
        },
        "pinocchio-errors": {
          "title": "Pinocchio Errors",
          "description": "Define custom error types with thiserror crate. Implement ProgramError conversion and handle no_std environments correctly."
        },
        "reading-and-writing-data": {
          "title": "Reading and Writing Data",
          "description": "Serialize and deserialize account data efficiently. Understand buffer bounds checking, alignment requirements, and safe memory operations."
        },
        "testing-your-program": {
          "title": "Testing your Program",
          "description": "Test Pinocchio programs with Mollusk framework. Set up complex account states, mock blockchain conditions, and run unit tests."
        },
        "performance": {
          "title": "Performance",
          "description": "Optimize Solana programs by removing superfluous checks. Use feature flags for production builds and minimize compute unit consumption."
        },
        "middleware-entrypoint": {
          "title": "Middleware Entrypoint",
          "description": "Create hot path entrypoint for high-frequency instructions. Process raw account data directly to eliminate deserialization overhead."
        },
        "batch-instructions": {
          "title": "Batch Instructions",
          "description": "Reduce CPI overhead by batching multiple operations. Process inner instructions sequentially in single cross-program invocation."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review Pinocchio fundamentals, TryFrom patterns, and native development. Build optimized Solana programs with hands-on challenges."
        }
      }
    },
    "introduction-to-assembly": {
      "title": "Introduction to Assembly",
      "description": "See what your Rust compiles to. Understand sBPF registers, memory operations, and how Solana actually executes your programs at the lowest level.",
      "lessons": {
        "assembly-101": {
          "title": "Assembly 101",
          "description": "Understand sBPF virtual machine and Solana program execution. Learn register-based architecture, syscalls, and deterministic runtime."
        },
        "registers-and-memory": {
          "title": "Registers and Memory",
          "description": "Master 11 sBPF registers and fixed memory regions. Access stack, heap, and input buffer for program execution."
        },
        "instructions": {
          "title": "Instructions",
          "description": "Learn sBPF instruction format with opcode, dst, src, offset, and imm fields. Understand data movement, arithmetic, and control flow."
        },
        "tooling": {
          "title": "Tooling",
          "description": "Install sBPF toolkit for building assembly programs. Use init, build, deploy, test commands for development workflow."
        },
        "program-example": {
          "title": "Program Example",
          "description": "Analyze NoOp program to understand sBPF execution flow. Decode instructions and trace register operations in binary format."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review sBPF architecture, registers, memory map, and instruction set. Optimize critical paths and debug with assembly knowledge."
        }
      }
    },
    "program-security": {
      "title": "Program Security",
      "description": "Don't get exploited. Learn how attackers hijack PDAs, forge signatures, and drain accounts. Then learn exactly how to prevent each attack. Essential reading.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Understand Solana security fundamentals and common vulnerabilities. Master account ownership, access controls, and cross-program invocations."
        },
        "signer-checks": {
          "title": "Signer Checks",
          "description": "Verify cryptographic signatures to prevent unauthorized access. Protect PDA operations and authority-gated instructions with signer validation."
        },
        "owner-checks": {
          "title": "Owner Checks",
          "description": "Validate account ownership before trusting data. Prevent malicious account substitution attacks with program_id verification."
        },
        "data-matching": {
          "title": "Data Matching",
          "description": "Validate account data relationships and expected values. Ensure logical consistency between accounts with has_one constraints."
        },
        "duplicate-mutable-accounts": {
          "title": "Duplicate Mutable Accounts",
          "description": "Prevent race conditions from passing same account twice. Detect duplicate accounts with constraint checks in instructions."
        },
        "reinitialization-attacks": {
          "title": "Reinitialization Attacks",
          "description": "Protect initialized accounts from malicious overwrite. Use init constraint and is_initialized flag to prevent hijacking."
        },
        "revival-attacks": {
          "title": "Revival Attacks",
          "description": "Secure account closure with data clearing and CLOSED_ACCOUNT_DISCRIMINATOR. Prevent zombie accounts with stale data exploitation."
        },
        "arbitrary-cpi": {
          "title": "Arbitrary CPI",
          "description": "Validate program addresses before cross-program invocations. Prevent malicious code execution with Program type constraints."
        },
        "type-cosplay": {
          "title": "Type Cosplay",
          "description": "Use discriminators to prevent account type impersonation. Distinguish structurally similar accounts with unique identifiers."
        },
        "pda-sharing": {
          "title": "PDA Sharing",
          "description": "Derive user-specific PDAs to prevent cross-contamination. Include user pubkey in PDA seeds for account isolation."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review Solana security patterns: owner checks, signer verification, data validation, and PDA isolation. Build secure programs."
        }
      }
    },
    "secp256r1-on-solana": {
      "title": "Secp256r1 on Solana",
      "description": "Enable passkey and WebAuthn support in your Solana programs. Implement Secp256r1 signatures with Anchor or Pinocchio. Let users sign with Face ID.",
      "lessons": {
        "introduction": {
          "title": "Secp256r1 on Solana",
          "description": "Learn secp256r1 elliptic curve cryptography fundamentals and SIMD 75 precompile. Understand P-256 mathematical foundations for passkey implementation."
        },
        "secp256r1-with-anchor": {
          "title": "Secp256r1 with Anchor",
          "description": "Verify secp256r1 signatures in Anchor programs. Implement passkey authentication with WebAuthn and the precompile instruction."
        },
        "secp256r1-with-pinocchio": {
          "title": "Secp256r1 with Pinocchio",
          "description": "Implement secp256r1 signature verification using Pinocchio. Build passkey authentication with compressed public keys and ECDSA signatures."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review secp256r1 signature verification concepts and best practices. Apply cryptographic knowledge to secure authentication systems on Solana."
        }
      }
    },
    "tokens-on-solana": {
      "title": "Tokens on Solana",
      "description": "Master Solana's token architecture with SPL Token program. Learn mint accounts, token accounts, authorities, and Token-2022 extensions. $0.02 token creation vs Ethereum's $50.",
      "lessons": {
        "introduction": {
          "title": "One Program, Every Token",
          "description": "Learn why Solana's single SPL Token program costs $0.02 vs Ethereum's $50 per token. Account-based model, composability, and how one program handles all tokens."
        },
        "mint-and-token-accounts": {
          "title": "Mint Accounts and Supply Control",
          "description": "Master mint accounts controlling token supply and authorities. Learn how USDC's $28B supply is managed, mint authority, freeze authority, and decimal configuration."
        },
        "functionalities": {
          "title": "Token Accounts and Ownership",
          "description": "Understand token accounts holding balances and Associated Token Accounts (ATAs). Learn deterministic derivation, rent costs, delegates, and why each token needs its own account."
        },
        "metaplex-token-metadata": {
          "title": "Token Extensions and Token-2022",
          "description": "Explore Token-2022's 16 extensions beyond SPL Token. Learn transfer fees, confidential transfers, metadata in mint accounts, and backwards compatibility with SPL Token."
        },
        "conclusion": {
          "title": "Key Takeaways",
          "description": "Review Solana token architecture with FAQ. Compare costs with Ethereum, understand when to use Token-2022, and learn next steps for building token applications."
        }
      }
    },
    "nfts-on-solana": {
      "title": "NFTs on Solana",
      "description": "Ship NFT collections on Solana. Master Token Metadata, Core, and compressed NFTs. Learn collections, royalties, verification. $0.02 vs Ethereum's $50 per NFT minting.",
      "lessons": {
        "introduction": {
          "title": "NFTs on Solana",
          "description": "Discover why Solana NFTs cost $0.02 vs Ethereum's $50-100. Learn Token Metadata, Core, and compressed NFTs storing millions in one account. Cost, speed, and scale advantages."
        },
        "metaplex-token-metadata": {
          "title": "Metaplex Token Metadata",
          "description": "Master Metaplex Token Metadata standard with mint accounts and metadata PDAs. Learn collections, royalties, creator verification, off-chain JSON, and programmable NFTs."
        },
        "metaplex-core": {
          "title": "Core and Compressed NFTs",
          "description": "Compare Token Metadata, Core, and compressed NFTs. Learn Merkle trees storing 1M NFTs for $600 vs $28,800. Understand cost, compatibility, and indexer trade-offs."
        },
        "conclusion": {
          "title": "Key Takeaways",
          "description": "Review NFT standards with decision framework and FAQ. Choose Token Metadata, Core, or compressed NFTs based on scale, cost, compatibility, and use case requirements."
        }
      }
    },
    "spl-token-with-web3js": {
      "title": "SPL Token with Web3.js",
      "description": "Build token apps in TypeScript. Mint, transfer, burn, freeze, and manage authorities using web3.js. Every operation you need for a token frontend.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Set up SPL Token Program with Web3.js library. Create Mint and Token accounts using system instructions and rent exemption patterns."
        },
        "mint-to": {
          "title": "Mint To",
          "description": "Create mint tokens instruction with Web3.js. Handle decimal normalization and Associated Token Account creation for token distribution."
        },
        "transfer": {
          "title": "Transfer",
          "description": "Implement token transfer between accounts using Web3.js. Build transactions with ATA creation and proper authority signing patterns."
        },
        "burn": {
          "title": "Burn",
          "description": "Permanently destroy tokens and reduce supply using burn instruction. Compare raw instructions with abstracted burn methods and checked variants."
        },
        "close-account": {
          "title": "Close Account",
          "description": "Close token accounts and reclaim rent lamports. Handle zero-balance requirements and destination account configuration with Web3.js."
        },
        "approve-and-revoke": {
          "title": "Approve and Revoke",
          "description": "Delegate token transfer authority with approve instruction. Revoke delegation to restore full account control using Web3.js methods."
        },
        "freeze-and-thaw": {
          "title": "Freeze and Thaw",
          "description": "Freeze token accounts to disable transfers with freeze authority. Thaw accounts to restore functionality using SPL Token freeze instructions."
        },
        "set-authority": {
          "title": "Set Authority",
          "description": "Change mint authority, freeze authority, or account owner. Transfer ownership or permanently revoke authorities using AuthorityType enum."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review SPL Token Program operations with Web3.js. Apply token creation, transfer, and authority management patterns to decentralized applications."
        }
      }
    },
    "spl-token-with-anchor": {
      "title": "SPL Token with Anchor",
      "description": "Control SPL tokens from your Anchor programs. CPI into token program for mints, transfers, burns, and authority changes. Build real token applications in Rust.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Set up SPL Token Program with Anchor framework and anchor-spl crate. Use Anchor macros to simplify Mint and Token account initialization."
        },
        "mint-to": {
          "title": "Mint To",
          "description": "Execute mint_to CPI in Anchor programs. Create tokens with proper authority validation and decimal-normalized amounts using anchor-spl."
        },
        "transfer": {
          "title": "Transfer",
          "description": "Perform token transfers using Anchor CPI context. Build Transfer instruction with source, destination, and authority account validation macros."
        },
        "burn": {
          "title": "Burn",
          "description": "Remove tokens from circulation with burn CPI in Anchor. Reduce total supply using anchor-spl burn instruction with authority checks."
        },
        "close-account": {
          "title": "Close Account",
          "description": "Close token accounts and reclaim rent with Anchor CPIs. Handle zero-balance requirements using CloseAccount instruction in programs."
        },
        "approve-and-revoke": {
          "title": "Approve and Revoke",
          "description": "Delegate token authority with approve CPI in Anchor. Revoke delegation using anchor-spl Revoke instruction for account control."
        },
        "freeze-and-thaw": {
          "title": "Freeze and Thaw",
          "description": "Freeze accounts to disable operations using FreezeAccount CPI. Thaw frozen accounts with freeze authority validation in Anchor programs."
        },
        "set-authority": {
          "title": "Set Authority",
          "description": "Change authorities using set_authority CPI with AuthorityType enum. Transfer mint, freeze, or account ownership in Anchor programs."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review SPL Token CPIs with Anchor framework. Apply anchor-spl patterns for token operations in production Solana programs."
        }
      }
    },
    "token-2022-program": {
      "title": "Token2022 Program",
      "description": "Token-2022 has 16+ extensions that SPL Token doesn't. Transfer fees, confidential transfers, permanent delegates, and more. The future of Solana tokens.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Learn how Token2022 extends SPL Token with extensions. Understand Mint and Token account differences and how extensions live on-chain."
        },
        "token-extensions": {
          "title": "Token Extensions",
          "description": "Explore Token2022 extensions including transfer fees, metadata, interest-bearing tokens, and security controls for programmable tokens."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Complete your Token2022 program knowledge. Learn next steps for implementing token extensions in TypeScript and Anchor programs."
        }
      }
    },
    "token-2022-with-web3js": {
      "title": "Token2022 with Web3.js",
      "description": "Use Token-2022 extensions in your TypeScript app. Transfer fees, interest-bearing tokens, metadata, and 9 more extensions. Build the next generation of token apps.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Set up Token2022 with Web3.js. Calculate extension space requirements and initialize Mint accounts with transfer fee configuration."
        },
        "transfer-fee-extension": {
          "title": "Transfer Fee Extension",
          "description": "Implement transfer fee taxation on token swaps using Web3.js. Configure fee basis points and withdraw withheld tokens from accounts."
        },
        "mint-close-authority-extension": {
          "title": "Mint Close Authority Extension",
          "description": "Enable mint account closure with MintCloseAuthority. Reclaim rent from zero-supply mints using close_account instruction."
        },
        "default-account-state-extension": {
          "title": "Default Account State Extension",
          "description": "Create frozen-by-default token accounts. Configure DefaultAccountState extension and manage freeze authority permissions."
        },
        "immutable-owner-extension": {
          "title": "Immutable Owner Extension",
          "description": "Prevent token account ownership changes with ImmutableOwner. Secure accounts against unauthorized transfers and access attempts."
        },
        "memo-transfer-extension": {
          "title": "Memo Transfer Extension",
          "description": "Enforce memo requirements on incoming transfers. Enable MemoTransfer extension for enhanced transaction tracking and compliance."
        },
        "non-transferable-extension": {
          "title": "Non Transferable Extension",
          "description": "Create soulbound tokens with NonTransferable extension. Prevent token transfers between accounts for credentials and achievements."
        },
        "interest-bearing-extension": {
          "title": "Interest Bearing Extension",
          "description": "Build interest-accruing tokens with InterestBearingConfig. Apply rates and calculate updated balances including interest over time."
        },
        "cpi-guard-extension": {
          "title": "CPI Guard Extension",
          "description": "Block malicious cross-program invocations with CpiGuard. Protect token accounts from unauthorized manipulation without explicit consent."
        },
        "permanent-delegate-extension": {
          "title": "Permanent Delegate Extension",
          "description": "Assign irrevocable delegates with PermanentDelegate. Enable authority to transfer or burn tokens from any account permanently."
        },
        "metadata-extension": {
          "title": "Metadata Extension",
          "description": "Embed on-chain metadata natively with Metadata and MetadataPointer extensions. Store name, symbol, URI without external programs."
        },
        "group-and-member-extension": {
          "title": "Group and Member Extension",
          "description": "Create NFT collections with Group and Member extensions. Link multiple assets using GroupPointer and MemberPointer references."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Master Token2022 with Web3.js. Apply your knowledge to create Mint and Token accounts with extensions in production applications."
        }
      }
    },
    "token-2022-with-anchor": {
      "title": "Token2022 with Anchor",
      "description": "CPI into Token-2022 from Anchor programs. Work with transfer fees, metadata, and 11 extensions. Build revenue-generating tokens and advanced token mechanics.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Implement Token2022 extensions using Anchor. Use InterfaceAccount and anchor-spl crate for Mint and Token account initialization."
        },
        "transfer-fee-extension": {
          "title": "Transfer Fee Extension",
          "description": "Build transfer fee extension with Anchor CPIs. Configure TransferFeeConfig and withdraw withheld tokens using raw instruction calls."
        },
        "mint-close-authority-extension": {
          "title": "Mint Close Authority Extension",
          "description": "Use Anchor macros for MintCloseAuthority. Simplify mint closure with extensions::close_authority::authority constraint."
        },
        "default-account-state-extension": {
          "title": "Default Account State Extension",
          "description": "Initialize frozen token accounts with Anchor. Configure DefaultAccountState using raw CPIs and AccountState enum values."
        },
        "immutable-owner-extension": {
          "title": "Immutable Owner Extension",
          "description": "Secure token ownership with Anchor ImmutableOwner. Calculate PodAccount size and initialize extension using manual CPIs."
        },
        "memo-transfer-extension": {
          "title": "Memo Transfer Extension",
          "description": "Require memos on transfers with Anchor. Initialize MemoTransfer extension using PodAccount space calculation and raw CPIs."
        },
        "non-transferable-extension": {
          "title": "Non Transferable Extension",
          "description": "Create soulbound tokens in Anchor programs. Initialize NonTransferable extension using ExtensionType and PodMint helpers."
        },
        "interest-bearing-extension": {
          "title": "Interest Bearing Extension",
          "description": "Implement interest-bearing tokens with Anchor. Configure rate parameters and initialize InterestBearingConfig using raw CPIs."
        },
        "cpi-guard-extension": {
          "title": "CPI Guard Extension",
          "description": "Note: CpiGuard cannot be initialized via CPI due to security restrictions. Extension must be enabled through direct user transactions."
        },
        "permanent-delegate-extension": {
          "title": "Permanent Delegate Extension",
          "description": "Assign permanent delegates with Anchor macros. Use extensions::permanent_delegate::delegate constraint for irrevocable authority."
        },
        "metadata-extension": {
          "title": "Metadata Extension",
          "description": "Embed metadata with Anchor and spl_token_metadata_interface. Initialize MetadataPointer and dynamically allocate metadata space."
        },
        "group-and-member-extension": {
          "title": "Group and Member Extension",
          "description": "Build NFT collections with Anchor Group extensions. Use spl_token_group_interface for GroupPointer and MemberPointer initialization."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Complete Token2022 with Anchor course. Master anchor-spl crate and extension macros for production Solana token programs."
        }
      }
    },
    "instruction-introspection": {
      "title": "Instruction Introspection",
      "description": "Read and validate other instructions in the same transaction. Essential for composability and security. Prevent malicious instructions from sneaking in.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Analyze transaction instructions with Instruction Introspection. Access Instructions sysvar to validate and respond to other instructions."
        },
        "introspection-with-anchor": {
          "title": "Introspection with Anchor",
          "description": "Use solana_program crate for Anchor introspection. Load instruction data with load_current_index_checked and validate program IDs."
        },
        "introspection-with-pinocchio": {
          "title": "Introspection with Pinocchio",
          "description": "Implement introspection in Pinocchio with zero-cost helpers. Use Instructions::new_unchecked for efficient sysvar access."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Master instruction introspection for transaction-level validation. Build secure cross-program interactions with dynamic instruction analysis."
        }
      }
    },
    "testing-with-mollusk": {
      "title": "Testing with Mollusk",
      "description": "Test your Solana programs in pure Rust. Mollusk gives you lightning-fast unit tests without spinning up validators. Mock accounts, test edge cases instantly.",
      "lessons": {
        "mollusk-101": {
          "title": "Mollusk 101",
          "description": "Test Solana programs efficiently with Mollusk. Use lightweight SVM harness for fast execution and precise account state control."
        },
        "advanced-functionalities": {
          "title": "Advanced Functionalities",
          "description": "Configure Mollusk with custom programs and sysvars. Benchmark compute units and test chained instructions with advanced APIs."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Complete Mollusk testing course. Apply SVM-based testing to Anchor and Pinocchio programs with compute unit benchmarking."
        }
      }
    },
    "solana-pay": {
      "title": "Solana Pay",
      "description": "Accept payments in your app with QR codes. Solana Pay lets users scan and pay instantly. Build transfer and transaction requests for real commerce.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Learn Solana Pay's URL-based payment framework. Understand transfer requests for simple payments and transaction requests for dynamic commerce."
        },
        "transfer-request": {
          "title": "Transfer Request",
          "description": "Build transfer request URLs for SOL and SPL token payments. Implement QR codes and track payments with reference parameters and memos."
        },
        "transaction-request": {
          "title": "Transaction Request",
          "description": "Create dynamic transaction endpoints that compose custom Solana transactions server-side. Handle GET and POST requests for interactive payments."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review Solana Pay implementation patterns. Apply transfer and transaction requests to build payment solutions with QR code integration."
        }
      }
    },
    "create-your-sdk-with-codama": {
      "title": "Create your SDK with Codama",
      "description": "Stop writing client code by hand. Codama generates type-safe TypeScript SDKs from your Anchor IDL. Update your program, regenerate, ship.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Discover Codama's IDL system for generating type-safe clients. Learn how nodes, visitors, and renderers automate SDK creation across languages."
        },
        "codama-from-scratch": {
          "title": "Codama IDL from Scratch",
          "description": "Build Codama IDLs using ValueNode, TypeNode, and DiscriminatorNode. Define accounts, instructions, and PDAs programmatically."
        },
        "codama-with-anchor": {
          "title": "Codama IDL with Anchor",
          "description": "Convert Anchor IDL to Codama format with rootNodeFromAnchor. Enhance generated IDLs using visitor transformations."
        },
        "updating-codama-idl": {
          "title": "Updating Codama IDL",
          "description": "Apply Codama visitors to add PDAs, rename fields, and optimize SDK developer experience. Transform IDL nodes programmatically."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review Codama IDL creation patterns from scratch and Anchor. Generate type-safe SDKs for Solana programs across multiple languages."
        }
      }
    },
    "winternitz-signatures-on-solana": {
      "title": "Winternitz Signatures on Solana",
      "description": "Quantum computers will break most crypto signatures. Winternitz signatures won't. Learn post-quantum cryptography on Solana before you need it.",
      "lessons": {
        "introduction": {
          "title": "Introduction",
          "description": "Learn post-quantum Winternitz signatures using hash-based cryptography. Understand hash chains, checksum mechanisms, and quantum resistance."
        },
        "winternitz-signatures-with-anchor": {
          "title": "Winternitz Signatures with Anchor",
          "description": "Implement Winternitz signatures in Anchor programs. Generate keys, sign messages, and verify signatures on-chain."
        },
        "winternitz-signatures-with-pinocchio": {
          "title": "Winternitz Signatures with Pinocchio",
          "description": "Use Dean's Pinocchio crate for quantum-resistant signatures. Handle w=8 parameter trade-offs for Solana's size and compute constraints."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review Winternitz signature implementation with Pinocchio. Build quantum-secure Solana programs using hash-based cryptography."
        }
      }
    },
    "testing-with-litesvm": {
      "title": "Testing with LiteSVM",
      "description": "Test Solana programs without running a validator. LiteSVM emulates the SVM in-process for instant feedback. Works in both TypeScript and Rust.",
      "lessons": {
        "litesvm-101": {
          "title": "LiteSVM 101",
          "description": "Discover LiteSVM's in-process Solana VM for fast program testing. Compare performance advantages over solana-program-test and test-validator."
        },
        "typescript": {
          "title": "LiteSVM with Typescript",
          "description": "Set up LiteSVM with TypeScript. Load programs, execute transactions, and manipulate account state for comprehensive testing scenarios."
        },
        "rust": {
          "title": "LiteSVM with Rust",
          "description": "Implement LiteSVM tests in Rust. Create transactions, configure accounts, and profile program execution with direct VM integration."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review LiteSVM testing patterns in TypeScript and Rust. Optimize test suites with in-process VM performance and account manipulation."
        }
      }
    },
    "testing-with-surfpool": {
      "title": "Testing with Surfpool",
      "description": "Advanced testing for Solana programs. Surfpool handles parallel test execution and complex state management. For teams shipping production code.",
      "lessons": {
        "surfpool-101": {
          "title": "Surfpool 101",
          "description": "Learn Surfnet local validator with on-demand mainnet account fetching. Test CPI-heavy programs without manual account dumps."
        },
        "advanced-functionalities": {
          "title": "Advanced Functionalities",
          "description": "Master Surfnet RPC calls for time travel, account modification, and system variable customization. Profile transactions and manipulate blockchain state."
        },
        "conclusion": {
          "title": "Conclusion",
          "description": "Review Surfpool testing strategies for complex CPI scenarios. Apply mainnet simulation and advanced controls to Solana program testing."
        }
      }
    },
    "mobile-dapp-fundamentals": {
      "title": "Solana Mobile Development: React Native & MWA Tutorial",
      "description": "Build native Solana dApps with Mobile Wallet Adapter protocol. Implement wallet connections, transaction signing, and authorization in React Native applications.",
      "lessons": {
        "introduction": {
          "title": "Introduction to Mobile Wallet Adapter",
          "description": "Discover why Mobile Wallet Adapter exists and how MWA differs from web wallet-adapter. Learn the session-based architecture for native Solana mobile apps."
        },
        "protocol-deep-dive": {
          "title": "Mobile Wallet Adapter Protocol Architecture",
          "description": "Understand MWA's request-response model, URI schemes, and session lifecycle. See how Android intents enable wallet communication in native apps."
        },
        "environment-setup": {
          "title": "React Native Solana Development Environment",
          "description": "Configure React Native for Solana mobile development. Install MWA libraries, set up Android emulators, and prepare your mobile development workspace."
        },
        "connecting-to-wallets": {
          "title": "Connecting to Solana Mobile Wallets",
          "description": "Implement wallet discovery and connection in React Native. Handle MWA authorization flows and establish secure sessions with mobile wallet apps."
        },
        "signing-transactions": {
          "title": "Transaction Signing in Mobile Wallet Adapter",
          "description": "Send transactions to mobile wallets for user approval. Handle signing responses, errors, and implement proper transaction confirmation patterns."
        },
        "signing-messages": {
          "title": "Message Signing with MWA",
          "description": "Request cryptographic message signatures from mobile wallets. Implement authentication proofs and verify signed messages in your React Native app."
        },
        "authorization-provider": {
          "title": "MWA Authorization Provider Pattern",
          "description": "Build reusable authorization context for your mobile dApp. Manage wallet state, persist sessions, and handle authorization across app restarts."
        },
        "error-handling": {
          "title": "Error Handling in Mobile Wallet Adapter",
          "description": "Handle MWA protocol errors, wallet rejections, and network failures. Implement user-friendly error messages and recovery strategies for mobile apps."
        },
        "testing-on-device": {
          "title": "Testing Solana Mobile dApps on Device",
          "description": "Test MWA integration on physical Android devices. Debug wallet connections, inspect transaction flows, and validate your mobile dApp behavior."
        },
        "conclusion": {
          "title": "Mobile dApp Fundamentals Conclusion",
          "description": "Review Mobile Wallet Adapter fundamentals and key implementation patterns. Next steps for building production-ready Solana mobile applications."
        }
      }
    },
    "mwa-deep-dive": {
      "title": "Mobile Wallet Adapter Protocol: ECDH, AES-GCM & JSON-RPC",
      "description": "Master MWA protocol internals: ECDH key exchange, AES-GCM encryption, JSON-RPC methods, identity verification, and debugging techniques for mobile wallets.",
      "lessons": {
        "architecture": {
          "title": "Mobile Wallet Adapter Architecture",
          "description": "Examine MWA's layered architecture: transport layer, encryption layer, and RPC layer. Understand how each component enables secure mobile wallet communication."
        },
        "transport-layer": {
          "title": "MWA Transport Layer Implementation",
          "description": "Understand Android intent-based transport and local socket connections. See how MWA establishes bidirectional communication between dApps and wallets."
        },
        "association": {
          "title": "MWA Association Protocol",
          "description": "Learn the MWA association handshake that initiates wallet sessions. Implement URI scheme handling and association request validation."
        },
        "session-establishment": {
          "title": "ECDH Session Establishment in MWA",
          "description": "Implement Elliptic Curve Diffie-Hellman key exchange for MWA sessions. Generate shared secrets and establish encrypted communication channels."
        },
        "encrypted-messages": {
          "title": "AES-GCM Encryption in Mobile Wallet Adapter",
          "description": "Encrypt and decrypt MWA messages using AES-GCM with ECDH-derived keys. Implement proper nonce handling and authentication tag verification."
        },
        "rpc-methods": {
          "title": "MWA JSON-RPC Method Reference",
          "description": "Complete reference for MWA JSON-RPC methods: authorize, reauthorize, deauthorize, sign_transactions, and sign_messages. Parameters and response formats."
        },
        "identity-verification": {
          "title": "Wallet Identity Verification in MWA",
          "description": "Verify wallet identity using MWA's cryptographic proofs. Implement wallet public key verification and prevent man-in-the-middle attacks."
        },
        "reflector-and-debugging": {
          "title": "MWA Reflector Protocol & Debugging Tools",
          "description": "Debug MWA sessions with reflector protocol. Inspect encrypted messages, trace protocol flows, and diagnose wallet communication issues."
        }
      }
    },
    "embedded-wallets": {
      "title": "Embedded Wallets: MPC, Passkeys & Smart Wallet Architecture",
      "description": "Eliminate seed phrases with embedded wallets. Compare MPC threshold signatures, passkey-native smart wallets, and modular signer architectures.",
      "lessons": {
        "introduction": {
          "title": "Introduction to Embedded Wallets",
          "description": "Understand why embedded wallets remove seed phrases and improve onboarding. Compare MPC, passkeys, and smart wallet approaches for Solana applications."
        },
        "mpc-cryptography": {
          "title": "Multi-Party Computation for Wallets",
          "description": "Learn threshold signature schemes and MPC key generation. Understand how distributed key shares enable seedless wallet architectures on Solana."
        },
        "passkeys-webauthn": {
          "title": "Passkeys and WebAuthn for Solana",
          "description": "Implement passkey-based authentication with WebAuthn. Use hardware-backed keys for Solana wallet signing without managing private keys."
        },
        "smart-wallet-architectures": {
          "title": "Smart Wallet Architectures on Solana",
          "description": "Design program-based smart wallets with modular signers. Implement session keys, spending limits, and recovery mechanisms using Solana programs."
        },
        "choosing-implementation": {
          "title": "Choosing Your Embedded Wallet Approach",
          "description": "Compare trade-offs between MPC, passkeys, and smart wallets. Select the right architecture based on security requirements, cost, and user experience."
        }
      }
    },
    "solana-mobile-client": {
      "title": "Solana Mobile: RPC, Tokens, NFTs & Program Interaction",
      "description": "Execute on-chain operations from mobile apps. Implement RPC connections, SPL token transfers, NFT operations with DAS API, and custom program interactions.",
      "lessons": {
        "introduction": {
          "title": "Introduction to Mobile On-Chain Operations",
          "description": "Overview of on-chain operations in mobile Solana apps. Understand RPC requirements, transaction construction, and mobile-specific optimization patterns."
        },
        "rpc-fundamentals": {
          "title": "Solana RPC from Mobile Applications",
          "description": "Configure RPC connections for mobile apps. Handle connection pooling, rate limiting, and implement fallback strategies for reliable mobile RPC access."
        },
        "token-operations": {
          "title": "SPL Token Operations on Mobile",
          "description": "Implement token transfers, balance queries, and account creation in mobile apps. Use @solana/spl-token with Mobile Wallet Adapter for token operations."
        },
        "nft-operations": {
          "title": "NFT Operations with DAS API on Mobile",
          "description": "Query and transfer NFTs using Digital Asset Standard API. Implement NFT galleries, metadata fetching, and collection queries in mobile applications."
        },
        "blinks-and-actions": {
          "title": "Solana Blinks and Actions on Mobile",
          "description": "Integrate Solana Actions and Blinks in mobile apps. Parse action URLs, render transaction previews, and execute blockchain actions from mobile interfaces."
        },
        "program-interaction": {
          "title": "Custom Program Interaction from Mobile",
          "description": "Interact with Solana programs from React Native. Build instructions, serialize account data, and invoke custom program methods in mobile applications."
        }
      }
    },
    "dapp-store-publishing": {
      "title": "Publish Solana Mobile Apps: dApp Store & App Store Review",
      "description": "Ship Solana mobile apps to production. Navigate Solana dApp Store, Apple App Store, and Google Play with APK signing, test accounts, and security best practices.",
      "lessons": {
        "introduction": {
          "title": "Introduction to Mobile dApp Distribution",
          "description": "Overview of distribution channels for Solana mobile apps. Compare Solana dApp Store, Apple App Store, and Google Play requirements and strategies."
        },
        "solana-dapp-store": {
          "title": "Publishing to Solana dApp Store",
          "description": "Submit your app to Solana dApp Store. Prepare metadata, screenshots, and app manifests. Meet dApp Store requirements for Solana mobile applications."
        },
        "app-store-strategies": {
          "title": "App Store Review Strategies for Crypto Apps",
          "description": "Navigate Apple and Google review for crypto apps. Provide test accounts, explain blockchain features, and pass app store review for Solana applications."
        },
        "mobile-security": {
          "title": "Mobile Security for Solana Applications",
          "description": "Implement security best practices for Solana mobile apps. Secure key storage, validate transactions, protect against common mobile vulnerabilities."
        },
        "production-best-practices": {
          "title": "Production Operations for Mobile dApps",
          "description": "Prepare mobile dApps for production. Implement crash reporting, analytics, RPC monitoring, and establish update strategies for live applications."
        }
      }
    }
  }
}
