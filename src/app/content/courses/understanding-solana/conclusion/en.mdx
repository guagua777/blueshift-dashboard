import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Key Takeaways

Blockchains replace trusted intermediaries with verifiable computation. [Bitcoin](/courses/blockchain-fundamentals/bitcoin-first-blockchain) proved this works but processes only 7 transactions per second. [Ethereum](/courses/evolution-programmable-blockchains/ethereum-programmable-money) added programmability but inherited sequential execution constraints, achieving 15 TPS. [Solana](/courses/understanding-solana/why-solana-built) approaches scalability differently through architectural innovation: order transactions first with Proof of History, then execute non-conflicting transactions in parallel.

[Proof of History](/courses/understanding-solana/why-solana-built#proof-of-history) is a cryptographic clock that creates verifiable timestamps without requiring nodes to synchronize clocks. Repeatedly hashing outputs into inputs creates a sequence proving time has passed. Transactions get hashed into this sequence, establishing their order before consensus. Solana orders 160,000 events per second, eliminating the ordering bottleneck that constrains sequential blockchains.

[Parallel execution](/courses/understanding-solana/why-solana-built#parallel-execution) requires transactions to declare which accounts they will access upfront. The runtime builds dependency graphs and executes non-conflicting transactions simultaneously across multiple CPU cores. [Stateless programs](/courses/understanding-solana/solana-architecture#stateless-programs) separate executable code from data, allowing concurrent execution when transactions touch different accounts.

[Everything is an account](/courses/understanding-solana/solana-architecture#everything-is-account) in Solana. [Accounts](/courses/understanding-solana/accounts-ownership) contain lamports, data, an owner, and an executable flag. Your wallet is an account. Programs are accounts. Token balances are accounts. Only the owning program can modify an account's data. This uniform model simplifies the architecture and enables parallel processing.

[Programs](/courses/understanding-solana/programs-transactions#programs-stateless-processors) process instructions by receiving accounts as parameters, validating operations, and modifying account data. [PDAs](/courses/understanding-solana/programs-transactions#program-derived-addresses) (Program Derived Addresses) let programs own accounts and authorize transactions without private keys. [CPI](/courses/understanding-solana/programs-transactions#cross-program-invocation) (Cross-Program Invocation) allows programs to call each other within atomic transactions. [Transactions](/courses/understanding-solana/programs-transactions#transactions-atomic-operations) bundle instructions that either all succeed or all fail together.

This architecture achieves 5,000+ TPS with sub-second finality. The tradeoff: validators need high-end hardware (12+ cores, 256GB RAM), reducing the number of potential validators compared to Bitcoin or Ethereum. Solana maintains over 1,000 independent validators, prioritizing throughput while maintaining sufficient decentralization for applications where performance matters most.

[Using Solana](/courses/understanding-solana/using-solana) requires a wallet to manage keys, SOL for transaction fees (0.000005 SOL per signature), and understanding that your seed phrase is the only way to recover funds. Wallets like Phantom, Solflare, and Backpack manage keys and sign transactions. Block explorers like Solana Explorer and Solscan show all on-chain data. The ecosystem includes DeFi protocols, NFT marketplaces, payment systems, and developer tools.

The tools exist. The infrastructure works. The ecosystem grows.

<ArticleSection name="Frequently Asked Questions" id="faq" level="h2" />

**What is Proof of History and why does Solana need it?**

Proof of History is a cryptographic clock that creates verifiable timestamps for blockchain events without requiring nodes to trust each other's clocks. It uses a verifiable delay function: repeatedly applying SHA-256 where each output becomes the next input. This creates a sequence that proves time has passed because you cannot skip ahead without doing the computation. Solana generates 160,000 hashes per second. When transactions arrive, they get hashed into this sequence, establishing their order cryptographically. Solana orders transactions before consensus rather than after, which eliminates the ordering bottleneck that limits sequential blockchains like Ethereum. Once ordered, Solana executes non-conflicting transactions in parallel.

**How does Solana achieve 5,000+ transactions per second?**

Solana achieves high throughput through three mechanisms. Proof of History orders transactions before consensus, eliminating consensus bottlenecks. Parallel execution requires transactions to declare which accounts they will access upfront, which lets the runtime build dependency graphs and execute non-conflicting transactions simultaneously across multiple CPU cores. Stateless programs separate executable code from data, enabling concurrent execution when transactions touch different accounts. The 400-millisecond block time and Tower BFT consensus with Proof of Stake achieve finality in 1-2 seconds. Production throughput is 5,000+ TPS with theoretical capacity exceeding 65,000 TPS.

**What is the Solana account model?**

In Solana, everything is an account. An account is a data structure containing lamports (balance in 1/billionth of a SOL), data (arbitrary bytes up to 10MB), an owner (the program controlling it), and an executable flag. Your wallet is an account owned by the System Program. Programs are accounts marked executable. Program data lives in separate accounts owned by the program. Token balances are accounts owned by the Token Program. This uniformity simplifies the model. Only the owning program can modify an account's data or withdraw its lamports. Transactions must declare which accounts they will access, which enables parallel execution when transactions touch different accounts.

**Why are Solana programs stateless?**

Solana programs contain only executable code with no internal state. Data lives in separate accounts owned by the program. When a program executes, it receives accounts as parameters, reads their data, processes it, and writes results back. Two transactions calling the same program with different data accounts can execute simultaneously because the program code is read-only and only the data accounts change. This separation enables parallel execution, simplifies program upgrades without data migration, and lets anyone inspect account data directly without executing program code. The stateless design is fundamental to Solana's high throughput.

**What is rent on Solana and how does it work?**

Rent is Solana's mechanism for maintaining account storage costs. Every account must maintain a minimum balance proportional to its data size to remain "rent-exempt." The formula: `rent = (128 + data_size) × 0.00000348 SOL × epochs_per_year`. A typical 165-byte account requires approximately 0.00114 SOL (about $0.11 at $100/SOL). This balance is a refundable deposit. When you close an account, the lamports return to you. Creating accounts costs SOL for rent deposits, but these costs are small and fully recoverable. Applications with thousands of accounts must account for total rent costs in their economics.

**How do I get started using Solana?**

Install a wallet like Phantom, Solflare, or Backpack. Write down your seed phrase (12 or 24 words) and store it securely. Never share it or save it digitally. Your seed phrase is the only way to recover your funds if you lose access. Get SOL from centralized exchanges (Coinbase, Binance), decentralized exchanges (Jupiter, Raydium), or on-ramps (Moonpay, Transak). For testing, use devnet with the Solana CLI: `solana config set --url https://api.devnet.solana.com` and `solana airdrop 2` for free test SOL. Transactions cost 0.000005 SOL and confirm in 1-2 seconds. Use block explorers like Solana Explorer or Solscan to view transactions and account data.

**What are the tradeoffs of Solana's architecture?**

Solana's high performance requires validators to run dedicated servers with 12+ CPU cores, 256GB RAM, and fast internet connections. This reduces the number of potential validators compared to Bitcoin or Ethereum where consumer laptops can validate. Solana maintains over 1,000 independent validators. Developers must declare accounts upfront in transactions, adding complexity compared to Ethereum's simpler sequential model. The network's high bandwidth requirements challenge validators in regions with limited infrastructure. These tradeoffs are intentional. Solana prioritizes throughput and cost while maintaining sufficient decentralization for applications where performance matters most.
