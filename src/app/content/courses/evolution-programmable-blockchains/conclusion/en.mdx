import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Key Takeaways

[Bitcoin proved blockchain works](/courses/blockchain-fundamentals/bitcoin-first-blockchain), but its limited scripting cannot support complex applications. [Ethereum](/courses/evolution-programmable-blockchains/ethereum-programmable-money) transformed blockchain from payments into programmable money. Smart contracts are programs that live on the blockchain, maintaining state and executing exactly as written without trusted intermediaries. This powers DeFi, NFTs, DAOs, and thousands of decentralized applications.

But Ethereum inherited Bitcoin's fundamental constraint: sequential execution. [The scalability challenge](/courses/evolution-programmable-blockchains/scalability-challenge) stems from the EVM executing transactions one after another. Smart contracts share global state. Without knowing which accounts a transaction will touch until execution, the runtime cannot determine which transactions are safe to run in parallel. This creates a throughput ceiling of approximately 15 transactions per second.

When demand exceeds capacity, users compete by bidding higher gas prices. Transaction fees have exceeded $50 for simple transfers and hundreds of dollars for complex interactions. High costs price out small users and prevent blockchain from scaling to mainstream adoption.

[Multiple solutions](/courses/evolution-programmable-blockchains/solutions-landscape) address this problem with different tradeoffs. Layer 2 rollups process transactions off-chain and post proofs to Layer 1, achieving 10-100x higher throughput while inheriting Ethereum's security. Sidechains sacrifice security guarantees for flexibility and speed. Sharding splits the network into parallel chains but adds complexity. Alternative Layer 1 blockchains redesign the architecture from first principles.

The blockchain trilemma explains why every solution makes tradeoffs. Blockchains can optimize for at most two of three properties: security, scalability, and decentralization. Layer 2 solutions maintain security and decentralization but add complexity. Alternative L1s achieve high throughput but often sacrifice decentralization. Breaking the trilemma requires architectural innovation, not parameter tuning.

[Solana](/courses/understanding-solana/why-solana-built) approaches scalability differently through Proof of History and parallel execution, achieving 5,000+ TPS on Layer 1 itself while maintaining sufficient decentralization for applications where performance matters most.

<ArticleSection name="Frequently Asked Questions" id="faq" level="h2" />

**What are Ethereum smart contracts?**

Ethereum smart contracts are programs that live on the blockchain and maintain state between executions. Unlike Bitcoin's limited scripting, Ethereum's Turing-complete virtual machine can run any computation. Developers write contracts in languages like Solidity that compile to EVM bytecode. Contracts have their own addresses, store persistent data, hold funds, and can call other contracts. When you send a transaction to a contract, every node executes the code and agrees on the result. This powers decentralized applications—lending protocols, token exchanges, NFT marketplaces, and DAOs—that execute exactly as programmed without requiring trust in any intermediary.

**Why is Ethereum slow and expensive?**

Ethereum processes approximately 15 transactions per second because the EVM executes transactions sequentially, one after another. Smart contracts share global state—when one contract modifies shared data, all other transactions must wait. Without knowing which accounts a transaction will touch until execution, the system cannot determine which transactions are safe to run in parallel. Sequential execution creates a fundamental throughput limit. When demand exceeds 15 TPS capacity, users compete for block space by bidding higher gas prices. During peak usage, transaction fees have exceeded $50 for simple transfers and hundreds of dollars for complex contract interactions, pricing out small users.

**What are Layer 2 solutions and how do they work?**

Layer 2 solutions execute transactions off the main blockchain (Layer 1), then post proofs or summary data back to Layer 1 for security. Execution is expensive, but verification is cheap. Rollups process thousands of transactions off-chain, batch them, and submit a single summary to Layer 1. Optimistic rollups assume transactions are valid unless challenged within a dispute period (typically 7 days). ZK rollups generate cryptographic proofs that transactions were executed correctly, giving instant finality. Both inherit Layer 1 security while achieving 10-100x higher throughput and lower costs. One Layer 1 transaction can include 1,000+ rollup transactions.

**What is the blockchain trilemma?**

The blockchain trilemma states that blockchains can optimize for at most two of three properties: security (resistance to attacks), scalability (high transaction throughput), and decentralization (many independent validators). Bitcoin chose security and decentralization, achieving 7 TPS. Ethereum chose security and decentralization, achieving 15 TPS. Visa chose security and scalability, achieving 65,000 TPS but with complete centralization. Increasing block size improves throughput but requires more resources to validate, reducing decentralization. Decreasing block time increases throughput but causes more forks, reducing security. The trilemma explains why "just make it faster" does not work—every scaling approach trades one property for another.

**What are rollups and how are they different from sidechains?**

Rollups inherit Layer 1 security by posting all transaction data or validity proofs to the main chain. If the rollup operator disappears, users can reconstruct their balances and withdraw funds using Layer 1 data. Sidechains maintain separate security through their own validators and consensus mechanisms. They connect to the main chain through bridges but do not inherit its security. If a sidechain's validators collude or fail, user funds can be lost. Rollups are more secure but constrained by Layer 1 data availability. Sidechains are more flexible but have weaker security guarantees. Choose rollups when security matters most, sidechains when throughput and cost are priorities.

**How does Solana solve the scalability problem?**

Solana solves scalability through architectural innovation rather than Layer 2 complexity. Proof of History creates verifiable timestamps that establish transaction order before consensus, removing the ordering bottleneck. Transactions must declare which accounts they will access upfront. The runtime builds a dependency graph and executes non-conflicting transactions in parallel across multiple CPU cores. Stateless programs separate code from data, allowing concurrent execution when transactions touch different accounts. This achieves 5,000+ TPS with sub-second finality on Layer 1 itself. But validators need high-end hardware (12+ cores, 256GB RAM), which reduces the number of participants who can validate compared to Bitcoin or Ethereum.
