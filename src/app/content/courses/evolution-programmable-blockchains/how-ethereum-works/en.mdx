import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# State, the EVM, and Gas

[Smart contracts](/courses/evolution-programmable-blockchains/ethereum-programmable-money#smart-contracts) let you build applications on blockchain. But how does Ethereum actually execute them? It comes down to persistent state that contracts can read and modify, a virtual machine that runs on every node, and a fee system that prevents abuse.

<ArticleSection name="What Is State?" id="what-is-state" level="h2" />

State is the current snapshot of all data on the blockchain—every account balance, every contract's stored variables, every token's ownership record. When you check your ETH balance, you are reading state. When you swap tokens on a decentralized exchange, you are changing state.

Every transaction modifies state. Alice sends 1 ETH to Bob: Alice's balance decreases by 1 ETH, Bob's increases by 1 ETH. That is a state transition. The blockchain is a sequence of state transitions, each triggered by a transaction.

A lending protocol's state includes every outstanding loan, every collateral deposit, every interest rate parameter. A decentralized exchange's state includes every liquidity pool's token reserves. This data persists between transactions—the contract remembers previous interactions and builds on them.

In traditional databases, a company stores and controls state. On Ethereum, state is replicated across thousands of nodes. No single entity controls it, and anyone can read or verify it.

<ArticleSection name="The Account Model" id="account-model" level="h2" />

Ethereum tracks state through accounts. Every address on Ethereum is an account with a balance, and some accounts also store code and data.

**Externally Owned Accounts (EOAs)** are controlled by private keys. When you use MetaMask or another wallet, you control an EOA. These accounts have a balance and can initiate transactions, but they do not store code.

**Contract Accounts** are controlled by code. They have a balance, store executable code, and maintain persistent data. Smart contracts live in contract accounts. No one holds a private key to a contract account—the code alone defines all behavior.

The distinction matters for state. EOAs only store a balance. Contract accounts store arbitrary data structures—maps of user balances, lists of orders, configuration parameters, anything the contract needs. When Uniswap tracks liquidity pool reserves, or Aave tracks outstanding loans, that data lives in contract account storage.

[Bitcoin uses a different model](/courses/blockchain-fundamentals/bitcoin-first-blockchain#utxo-model)—UTXOs track individual "coins" rather than account balances. Smart contracts need persistent, complex state. Ethereum's account model provides it.

<ArticleSection name="The Ethereum Virtual Machine" id="ethereum-virtual-machine" level="h2" />

The Ethereum Virtual Machine (EVM) is the runtime that executes smart contracts. It runs identically on every node in the network.

Developers write contracts in Solidity, a high-level language. The compiler translates Solidity into EVM bytecode—low-level instructions the virtual machine can execute. Every Ethereum node runs the same bytecode through the same virtual machine, guaranteeing every node reaches the same result.

The EVM is deterministic: given the same state and the same transaction, it always produces the same output. If different nodes could get different results from identical inputs, the network could not reach consensus on the correct state.

Contracts run in a sandbox. A contract cannot access files on the host computer, make network requests, or affect anything outside the blockchain. This isolation protects the nodes that execute contract code.

The EVM processes transactions sequentially—one at a time. Each transaction reads state, executes logic, and writes updated state before the next transaction begins. This sequential execution guarantees consistency but limits throughput. This is why [Ethereum has a scalability problem](/courses/evolution-programmable-blockchains/scalability-challenge).

<ArticleSection name="Gas: Paying for Computation" id="gas" level="h2" />

Every EVM operation costs gas—a unit measuring computational work. Gas prevents abuse and compensates validators.

Without gas, anyone could deploy a contract containing an infinite loop. Validators would execute it forever, unable to process other transactions. Gas ensures every computation has a bounded cost. When gas runs out, execution stops.

When you send a transaction, you specify:
- **Gas limit:** Maximum gas you will spend
- **Gas price:** How much ETH you pay per unit of gas (in gwei, where 1 gwei = 0.000000001 ETH)

Your maximum cost is `gas limit × gas price`. If the transaction uses less gas than the limit, the difference is refunded. If it needs more gas than the limit, the transaction reverts—but you still pay for the gas already consumed.

A simple ETH transfer costs 21,000 gas. A complex DeFi interaction might cost 200,000 gas or more. At a gas price of 50 gwei, that is 0.00105 ETH for a transfer (~$2 at $2,000/ETH) and 0.01 ETH for a DeFi operation (~$20).

When demand exceeds block capacity, users compete for space by bidding higher gas prices. Validators prioritize transactions that pay more. During the 2021 NFT boom, gas fees exceeded $50 for a simple transfer and over $200 for complex interactions. A user trying to swap $50 of tokens will not pay $80 in gas to do it.

Gas creates a market for block space. But the market exposes a hard limit: [sequential execution caps how much block space exists](/courses/evolution-programmable-blockchains/scalability-challenge), no matter what users are willing to pay.
